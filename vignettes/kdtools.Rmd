---
title: 'KD-Sort: A compact, tree-free, locality-preserving sorting and searching method for multi-dimensional data'
author: "Timothy H. Keitt"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
library(kdtools)
library(cowplot)
library(tidyverse)
library(microbenchmark)
library(foreach)
library(doMC)
library(tidytext)
registerDoMC()
```

Sorting and searching are fundamental operations in computer and data science. A canonical method for improving search performance is to place data into an ordered tree structure, the most common being a binary tree and its variants. Computer textbooks and introductory courses are littered with examples of tree structures, however it has been pointed out by practitioners that many tree-type data structures have considerable storage overhead and poor memory locality. This results from using linked-list-like pointers to connect nodes. In many cases, a sorted buffer combined with binary search will outperform pointer-based trees. Indeed, the C++ Standard Template Library (STL) comes with a set of algorithms for sorting or partitioning a data sequence and searching within partitioned sequences.

A limitation of the STL algorithms and data structures is that they can only be ordered in a single dimension. Sort keys can be higher cardinality however comparison operators and ordering are unidimensional. This is suboptimal for data that are intrinsically multidimensional, such as geographical coordinates or multivariate data. In multiple dimensions, it is preferred to order a sequence of keys such that a measure of distance is minimized between nearby pairs of elements. There are a vast array of techniques to accomplish spatial locality; however I will only discuss one known as the kd-tree. A kd-tree is a type of binary tree that cycles among the dimensions of its stored objects at each level of the tree hierarchy. In the case of spatial data, the root node will contain the median key in the x-direction and each of its daughter nodes will contain the median in the y-direction of their respective partitions. Subsequent daughter nodes will again contain medians in the x-direction, and so on until there are no additional keys to the left or right. Searching a kd-tree involves recursive comparisons, again cycling among the dimensions, until a leaf-node is encountered. Most searching operations can be accomplished in linear or logarithmic time complexity yielding an efficient method.

Precisely as an ordinary binary tree can be replaced by a sorted range, a sequence of multidimensional elements can be sorted, in-place if required, via recursive partitioning following the kd-tree scheme. Recursive partitioning is a well-known sorting algorithm and is the basis of quicksort. Partitioning a sequence places all elements less than (or more generally meeting some predicate) to the left of a selected key, while all elements greater-than-or-equal-to follow to the right. The kd-sort algorithm presented here simply modifies quicksort to cycle among the dimensions of the stored elements. Searching follows exactly as the kd-tree except that nodes correspond to pivot-elements in the linear array.

The kd-sort algorithm in the kdtools package is implemented as a C++ function template parameterized by the starting dimension (usually 0) and the iterator type. The iterator type can be auto-deduced by the compiler.

```{Rcpp eval=FALSE}
template <size_t I, typename Iter>
void kd_sort(Iter first, Iter last)
{
  using TupleType = iter_value_t<Iter>;
  constexpr auto J = incr_wrap<I, TupleType>::value;
  if (distance(first, last) > 1)
  {
    auto pred = kd_less<I>();
    auto pivot = middle_of(first, last);
    nth_element(first, pivot, last, pred);
    pivot = adjust_pivot(first, pivot, pred);
    kd_sort<J>(next(pivot), last);
    kd_sort<J>(first, pivot);
  }
}
```
The code utilizes the ```nth_element``` function from the C++ Standard Library. The ```nth_element``` algorithm partially sorts a range such that the element pointed to by the pivot iterator is the one that would be in that position if the range was fully sorted. Since the pivot is chosen as the middle element, after calling ```nth_element```, it points to the median key. The ```nth_element``` algorithm furthermore partitions the data such that all of the elements to the right of the pivot are not-less-than elements to the left. This is sufficient to recursively sort the range, however it will fail when there are enough ties that the first instance of the median key falls to the left of the pivot. A second partitioning pass, ```adjust_pivot``` is therefore required to ensure the pivot points to the first occurrence of the median key in the sequence. Adjust_pivot is thin wrapper around the ```partition``` algorithm from the Standard Library.

Once the first dimension is partitioned, the ranges right and left of the pivot are partitioned, and so on until first and last span a single or no value. The dimension index ```I``` is incremented at compile-time using template metaprogramming. The result is a sequence ordered as if it were inserted into a kd-tree data structure. The following figure illustrates the resulting order in 2-dimensions.

```{r echo=FALSE, fig.width=6, fig.height=6}
nr = 5e3
x = matrix(runif(nr), nc = 2)
y = kd_sort(matrix_to_tuples(x))
z = as.data.frame(tuples_to_matrix(y))
z$i = 1:nrow(z)
names(z) = c("x", "y", "i")
ggplot(z, aes(x, y)) +
  geom_path(color = "darkgrey") +
  geom_point(size = 0.25) + 
  geom_point(aes(color = i), alpha = 0.15, size = 5) +
  scale_color_gradientn(colors = rainbow(100)) +
  guides(color = FALSE) +
  coord_fixed()
```

Here the sequence order is shown with a continuous color gradient. The resulting patchiness indicates a hierarchical quad-tree-like partitioning of the space providing the desired locality. Placing nearby points in proximity is what allows for efficient searches once the data are sorted.

To ensure the correct behavior in the presence of multiple ties, or even when all keys in one dimension are equal, the ```kd_less``` predicate implements circular lexicographic comparison. If elements in one dimension are tied, the next dimension is interrogated to break the tie. The comparisons cycle from trailing dimensions to leading dimensions using modulo arithmetic. It is implemented as a recursive-template function object with the dimension index incremented at compile-time. SFINAE is used to stop the compile-time iteration after ```tuple_size<TupleType>::value``` steps.

```{Rcpp eval=FALSE}
template <size_t I, size_t N = 0>
struct kd_less
{
  template <typename TupleType>
  typename enable_if<is_not_last<N, TupleType>::value, bool>::type
  operator()(const TupleType& lhs, const TupleType& rhs) const
  {
    constexpr auto J = incr_wrap<I, TupleType>::value;
    return get<I>(lhs) == get<I>(rhs) ?
      kd_less<J, N + 1>()(lhs, rhs) :
        get<I>(lhs) < get<I>(rhs);
  }
  template <typename TupleType>
  typename enable_if<is_last<N, TupleType>::value, bool>::type
  operator()(const TupleType& lhs, const TupleType& rhs) const
  {
    return get<I>(lhs) < get<I>(rhs);
  }
};
```

A more general function object template ```kd_compare``` that takes an arbitary binary predicate is also provided. Notice that the only requirement is that the ```get<I>``` function return an object meeting the EqualityComparable C++ concept. This means that different dimensions can contain different data types, including strings, for example.

Function templates | STL analog | Outcome
-----------------|--------------|------------------------------------
kd_sort             |  sort   | sorts range
kd_lower_bound        | lower_bound | finds first element not less than key for all dimensions
kd_upper_bound        |  upper_bound | finds first element greater than key for all dimensions
kd_binary_search     | binary_search | returns true if key exists in range
kd_equal_range        | equal_range | returns an iterator pair spanning all occurrences of a key
kd_range_query       |  lower_bound, upper_bound     | finds all elements not less than lower and less than upper
kd_nearest_neighbor   |           | finds nearest neighbor of key
kd_nearest_neighbors  |            | finds k-nearest neighbors of key
kd_approx_nn         |              | finds first key closer than epsilon



```{r eval=FALSE}
nr_steps = 7
nr_min = 1e1
nr_max = 1e7
des = expand.grid(nr = round(seq(nr_min, nr_max, length = nr_steps)), nc = seq(1, 9, 2))
timer = function(nr, nc)
{
  x = matrix_to_tuples(matrix(runif(nr * nc), nr))
  summary(microbenchmark(kd_sort(x, T), times = 1), unit = "s")$median
}
t = foreach(i = 1:nrow(des), .combine = c) %dopar% timer(des[i, 1], des[i, 2])
df = cbind(des, t)
```

```{r eval=FALSE}
ggplot(df) +
  aes(x = nr, y = t, color = as.factor(nc)) +
  geom_line() + geom_point() +
  #scale_x_log10() + scale_y_log10() +
  #guides(color = FALSE) +
  xlab("Tuples") + ylab("Seconds") +
  theme(legend.position = "bottom") +
  labs(color = "D") -> p1
```

```{r eval=FALSE}
des = expand.grid(nr = seq(nr_min, nr_max, length = nr_steps), nc = seq(1, 9, 2))
timer = function(nr, nc)
{
  x = matrix_to_tuples(matrix(runif(nr * nc), nr))
  summary(microbenchmark(kd_sort(x, T, T), times = 1), unit = "s")$median
}
t = foreach(i = 1:nrow(des), .combine = c) %dopar% timer(des[i, 1], des[i, 2])
df = cbind(des, t)
```

```{r eval=FALSE}
ggplot(df) +
  aes(x = nr, y = t, color = as.factor(nc)) +
  geom_line() + geom_point() +
  #scale_x_log10() + scale_y_log10() +
  #guides(color = FALSE) +
  xlab("Tuples") + ylab("Seconds") +
  theme(legend.position = "bottom") +
  labs(color = "D") -> p2
```

```{r eval=FALSE}
des = expand.grid(nr = seq(nr_min, nr_max, length = nr_steps), nc = seq(1, 9, 2))
timer = function(nr, nc)
{
  x = matrix_to_tuples(matrix(runif(nr * nc), nr))
  summary(microbenchmark(lex_sort(x, T), times = 1), unit = "s")$median
}
t = foreach(i = 1:nrow(des), .combine = c) %dopar% timer(des[i, 1], des[i, 2])
df = cbind(des, t)
```

```{r eval=FALSE}
ggplot(df) +
  aes(x = nr, y = t, color = as.factor(nc)) +
  geom_line() + geom_point() +
  #scale_x_log10() + scale_y_log10() +
  #guides(color = FALSE) +
  xlab("Tuples") + ylab("Seconds") +
  theme(legend.position = "bottom") +
  labs(color = "D") -> p3
```

```{r  eval=FALSE, fig.height = 4, fig.width = 8}
plots = plot_grid(p1 + ylim(0, 5) + theme(legend.position = "none"),
                  p2 + ylim(0, 5) + theme(legend.position = "none") + ylab(""),
                  p3 + ylim(0, 5) + theme(legend.position = "none") + ylab(""),
                  align = "v", axis = "l", nrow = 1)
legend = plot_grid(ggplot(), get_legend(p1), ggplot())
plot_grid(plots, legend, nrow = 2, rel_heights = c(1, 0.15), align = "vh")
```

```{Rcpp}
// [[Rcpp::depends(kdtools)]]
// [[Rcpp::plugins(cpp11)]]

#include <Rcpp.h>
using Rcpp::CharacterVector;
using Rcpp::Rcout;
using Rcpp::stop;

#include <utility>
using std::begin;
using std::end;

#include <tuple>
using std::tuple;

#include <vector>
using std::vector;

#include <string>
using std::string;

#include <kdtools.h>
using kdtools::kd_sort;
using kdtools::kd_range_query;

using key_type = tuple<string, string>;
using range_type = vector<key_type>;

void print_range(const range_type& x)
{
  auto n = x.size();
  if (n < 10) stop("Not enough rows");
  for (int i = 0; i != 5; ++i)
    Rcout << i << " "
          << std::get<0>(x[i]) << " " 
          << std::get<1>(x[i]) << std::endl;
  Rcout << "..." << std::endl;
  for (int i = n - 5; i != n; ++i)
    Rcout << i << " "
          << std::get<0>(x[i]) << " " 
          << std::get<1>(x[i]) << std::endl;
}

// [[Rcpp::export]]
void query_strings(CharacterVector c1, CharacterVector c2)
{
  auto n = c1.size();
  range_type str_pairs;
  str_pairs.reserve(n);
  auto f = [](const char* a, const char* b){ return key_type(a, b); };
  transform(begin(c1), end(c1), begin(c2), back_inserter(str_pairs), f);
  
  kd_sort(begin(str_pairs), end(str_pairs));
  Rcout << "\nFirst and last 5 elements of sorted data:\n" << std::endl;
  print_range(str_pairs);
  
  range_type queried;
  kd_range_query(begin(str_pairs), end(str_pairs),
                 key_type("b", "q"), key_type("v", "s"),
                 back_inserter(queried));
  kd_sort(begin(queried), end(queried));
  Rcout << "\nFirst and last 5 elements of query return:\n" << std::endl;
  print_range(queried);
}
```

```{r}
data("parts_of_speech")
query_strings(tolower(parts_of_speech[[2]]),
              tolower(parts_of_speech[[1]]))
```
